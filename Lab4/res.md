## В рамках задачи выполнялось сравнение 4 различных коллекций, каждая из которых добавляла элемент по ключу. Количество ключей было ограничено 30. После выполнялась проверка размера коллекций.
### Рассмотрены 4 коллекции - потоконебезопасная HashMap, а также потокобезопасные Hashtable, Collections.synchronizedMap и ConcurrentHashMap. Использовалось 20 потоков.

### При работе HashMap появлялся некорректный размер коллекции из-за того, что с ним могли работать сразу несколько потоков.
**Размер map: 32**\
**Ошибка: размер превышает ожидаемый 30!**\
**...done.**

#### Такие результаты безусловно связаны с тем, что HaspMap является потоконебезопасной коллекцией и не может обеспечить корректный результат при параллельном выполнения, когда нужен конкурентный доступ нескольких потоков к ресурсу.

### Результат исполнения кода с Hashtable:
**java.util.Hashtable**\
**Размер map: 30**\
**Размер корректен.**\
**...done.**

#### Hashtable уже является потокобезопасной коллекцией и может обеспечить корректный результат при конкурентном доступе.

### Результат исполнения кода с Collections.synchronizedMap:
**java.util.Collections$SynchronizedMap**\
**Размер map: 30**\
**Размер корректен.**\
**...done.**

#### Collections.synchronizedMap также является потокобезопасной коллекцией и может обеспечить корректный результат при конкурентном доступе.

### Результат исполнения кода с ConcurrentHashMap:
**java.util.concurrent.ConcurrentHashMap**\
**Размер map: 30**\
**Размер корректен.**\
**...done.**

#### ConcurrentHashMap также является потокобезопасной коллекцией и может обеспечить корректный результат при конкурентном доступе.

### Также было произведено сравнение времени выполнения кода при использовании различных коллекций:

**Время выполнения:**\
**HashMap: 0.361 s,**\
**HashTable: 3.058 s,**\
**SyncMap: 2.976 s,**\
**ConcurrentHashMap: 0.628 s.**

##### Как видно из результатов, HashMap не стоит использовать, когда необходима коллекция, к которой будет конкурентный доступ. Наиболее быстрой и при этом безопасной коллекцией является ConcurrentHashMap. Связано это с тем, что в отличие от HashTable и synchronizedMap, которые блокируются полностью при доступе к ним, в ConcurrentHashMap блокируются лишь отдельные бакеты, что позволяет другим потокам в это время вести работу с другими бакетами.